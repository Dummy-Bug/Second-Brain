[[04 Base Encodings.pdf]]

**Base62** is a number encoding system that uses **62 URL-safe characters**:

`0–9  → 10 A–Z  → 26 a–z  → 26 ---------------- Total = 62 characters`

No special characters. No delimiters. No encoding required.

---

## Why Base62 is perfect for short URLs

Base62 was not invented for math elegance.  
It was invented for **human-facing identifiers inside URLs**.

---

## How Base62 works (conceptually)

Same number → different representation.

Example:

`Decimal ID: 125 Base62:     cb`

Large BIGINT:

`9223372036854775807 (decimal) → AzL8n0Y58m7`

Now your URL becomes:

`https://s.io/AzL8n0Y58m7`

Still globally unique. Much shorter. Clean.

---

## How you would use Base62 in a URL shortener

### Flow

1. DB generates BIGINT ID
    
2. Encode ID → Base62 string
    
3. Expose Base62 string as short URL
    
4. On redirect:
    
    - Decode Base62 → BIGINT
        
    - Fetch original URL
        
    - Redirect
        

No collisions. No randomness needed.

---

## Problems Base62 solves (mapping to your earlier list)

### 1. URL-safe characters ✅

Base62 uses:

`[0-9][A-Z][a-z]`

No:

- `/`
    
- `+`
    
- `%`
    
- `=`
    

So:

`GET /AzL8n0Y58m7`

Always a single path segment.

---

### 2. Short length ✅

|Encoding|Length (BIGINT max)|
|---|---|
|Decimal|19|
|Base16|16|
|Base64|~11 (but unsafe)|
|**Base62**|**~11 (safe)**|

This is the sweet spot.

---

## What Base62 does **not** solve (be honest)

### 1. Predictability ❌

Base62-encoded IDs are **still sequential**.

`125 → cb 126 → cc 127 → cd`

Attackers can still enumerate.

---

### 2. DB coupling ❌

You are still:

- Exposing internal primary keys
    
- Tying URL format to ID strategy
    

A future switch to UUID breaks everything.

---

### 3. Case sensitivity ⚠️

Base62 is case-sensitive:

`a ≠ A`

This:

- Increases entropy (good)
    
- Increases human error (bad)
    

Most systems accept this trade-off.


---

## When Base62 is a good choice

Base62 is a **strong, practical default** when:

- You want short URLs fast
    
- You accept predictability risk
    
- You want zero collision logic
    
- You control access or rate limiting
    

Many production systems stop here.